<!doctype html>
<html>
  <head>
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta charset="utf-8">
    <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
    <!-- Use title if it's in the page YAML frontmatter -->
    <title>Middleman</title>
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
    
    <link href="/stylesheets/site.css" rel="stylesheet" />
    <script src="/javascripts/all.js"></script>
    <script src="/javascripts/main.js"></script>
      </head>
  <body class="getting-started getting-started_part-3">
    
<header class="top">
	<div class="container">
		<a href="/index.html" class="logo"><img src="/images/Go_logo.png" /></a>
		<nav class="mainnav">
			<ul class="level0">
				<li class="dropdown">
					<a href="/features.html">Features</a>
					<ul>
						<li><a href="/plugins.html">Plugins</a></li>
						<li><a href="roadmap.html">Roadmap</a></li>
						<li><a href="/subscribe.html">Subscribe to updates</a></li>
					</ul>
				</li>
				<li class="dropdown">
					<a href="/community.html">Community</a>
					<ul>
						<li><a href="/contribute.html">Contribute</a></li>
						<li><a href="/cla.html">CLA</a></li>
						<li><a href="/open-issues.html">Open Issues</a></li>
						<li><a href="events.html">Events</a></li>
						<li><a href="partners.html">Partners</a></li>
					</ul>
				</li>
				<li><a href="#">Blog</a></li>
				<li class="dropdown">
					<a href="/help.html">Help</a>
					<ul>
						<li><a href="getting-started/part-1.html">Getting started</a></li>
						<li><a href="/download.html">Download</a></li>
					</ul>
				</li>
			</ul>
		</nav>
		<button class="navbtn menu collapse">
		<span></span>
		</button>
	</div>
</header>
<span id="top"></span>
    <div class="inner-banner">
	<div class="container">
		<h1 class="caption"><span>Getting started with GoCD</span></h1>
	</div>
</div>
<div class="container">
	<div class="row">
		<div class="col-sm-3">
			<nav class="getting-started-nav">
				<h5>Getting started</h5>
				<ul class="verticalnav">
					<li class="dropdown  dropdown-menu">
						<a href="#" class="active">Part 1</a>
						<ul>
							<li><a href="#installation">Installation</a></li>
							<li><a href="part-1.html#concept1" class="active">
								<strong>Concept 1:</strong>
							Server and agents </a></li>
							<li><a href="#concept2">
								<strong>Concept 2:</strong>
							Pipelines and materials </a></li>
							<li><a href="#concept3">
								<strong>Concept 3:</strong>
							Agent prepares to do some work </a></li>
							<li><a href="#concept4"> <strong>Concept 4:</strong>Stages, jobs and tasks </a></li>
						</ul>
					</li>
					<li class="dropdown  dropdown-menu">
						<a href="#">Part 2</a>
						<ul>
							<li><a href="#pipeline_as_material">Using a pipeline as a material</a></li>
							<li><a href="#concept_pipeline_dependency_material"><strong>Concept 5:</strong>	Pipeline Dependency Material </a></li>
							<li><a href="#using_artifacts">Publishing, fetching and using artifacts</a></li>
								<li><a href="#concept_artifact"><strong>Concept 6:</strong>Artifact </a></li>
								<li><a href="#fetching_using_artifacts">Fetching and using artifacts</a></li>
								<li><a href="##concept_ancestor_artifacts"><strong>Concept 7:</strong>Ancestor artifacts and building artifacts only once </a></li>
								<li><a href="#custom_tabs">Custom tabs</a></li>
								<li><a href="#concept_custom_tab"><strong>Concept 8:</strong> Custom tab</a></li>

							</ul>
						</li>
					<li class="dropdown open">
						<a href="#">Part 3</a>
						<ul>
							<li><a href="#value_stream_map">Value Stream Map (VSM)</a></li>
							<li><a href="#concept_vsm"><strong>Concept 9:</strong>	Value Stream Map </a></li>
							<li><a href="#fan_out_fan_in">Fan-Out and Fan-In</a></li>
								<li><a href="#concept_fan_out_fan_in"><strong>Concept 10:</strong>Fan-Out and Fan-In</a></li>
							</ul>
						</li>						
					</ul>
				</nav>
			</div>
			<div class="col-sm-9">
				<div class="getting-started-content">
					


            <p>In <a href="https://go.cd/getting-started/part-1.html">Part 1</a> of this guide, the concepts of GoCD Server, GoCD Agents,
pipelines, materials, stages, jobs and tasks were introduced. You were also able to get a simple pipeline with a single
stage, job and task each working.</p>

<p>In <a href="/getting-started/part-2.html">Part 2</a>, you learnt about using pipelines as materials
(dependency materials), artifacts and custom tabs.</p>

<p>Let us continue, in this part, by learning about the Value Stream Map (VSM) and about fan-in and fan-out.</p>


<h2 class="big-title" id="value_stream_map">Value Stream Map (VSM)</h2>

<section class="concept" id="concept_vsm">
  <h3><a></a>Concept 9: Value Stream Map (VSM)</h3>

  <p>
    The Value Stream Map is the full end-to-end (from commits to production) view across pipelines, and maps to the
    concept of a "Continuous Delivery Pipeline" or "Deployment Pipeline", in the book, "Continuous Delivery" by Jez
    Humble and David Farley. In their book, a couple of different views of a Deployment Pipeline are presented:
  </p>

  <figure>
    <img src="/images/image01.png">
    <figcaption>
      The idea is that, as you go closer to production, the confidence of the build's production readiness
      increases. (Image © Humble, Farley)
    </figcaption>
  </figure>

  <figure>
    <img src="/images/image02.png">
    <figcaption>
      This depicts the interactions between source code repositories, artifact repositories and different
      stages of the Deployment Pipeline. (Image © Humble, Farley)
    </figcaption>
  </figure>

  <p>
    A corresponding representation of a Value Stream Map in GoCD looks like this:
  </p>

  <figure>
    <img src="/images/image03.png">
  </figure>

  <p>
    There are some unfortunate differences in naming between GoCD and the book. What is termed as a "Stage of a Deployment
    Pipeline" in the book is called a "Pipeline" in GoCD. The "Deployment Pipeline" (end-to-end) is called the "Value
    Stream Map". In the rest of this guide, the term "Pipeline" will refer to a GoCD Pipeline and the term "Stage" will
    refer to a "Stage of a GoCD pipeline".
  </p>

  <p>
    Interestingly, Jez Humble was the first product manager of GoCD, and was around while these naming decisions were
    made. Rumour has it that he regrets the choice of the overloaded term, "Pipeline". :)
  </p>

  <p>
    The previously defined concepts of a Pipeline, Artifact and Pipeline Dependency (chaining of pipelines) come
    together to enable a true end-to-end Deployment Pipeline, which is known as a Value Stream Map (VSM) in GoCD. . The
    ability to do this, and so this concept is important because:
  </p>

  <ol start="1">
    <li>
      <strong>Abstraction</strong>: It is a level of abstraction in modeling, and allows you to hide (by default) what
      is going on underneath and not have to know the details unless you need to. It helps talk about and reason about
      your end-to-end workflow at a different level.
    </li>
    <li>
      <strong>Build once</strong>: This allows artifacts to be propagated through the pipelines. As mentioned in the
      Artifact concept definition, this enables an important CD concept, "Only Build Your Binaries Once".
    </li>
    <li>
      <strong>Parallelization</strong>: This provides another approach to parallelize your workflow. In the example
      above, the User Acceptance Pipeline and the Capacity Testing Pipeline can run simultaneously, providing quicker
      feedback. This will be discussed later in this guide, in the Fan-In/Fan-Out section.
    </li>
    <li>
      <strong>Traceability</strong>: This provides true auditability and traceability, all the way from a commit to
      production. You know exactly what went into production.
    </li>
  </ol>
</section>

<p>To use a Value Stream Map in GoCD, you don't really need to do anything. If you've pipelines which use pipeline
dependencies, then you can always get a VSM at the click of a button. Here is a dashboard view of pipelines which map to
the example shown in the concept. Clicking on the label (marked in red boxes) of any of the pipelines shows the VSM from
the perspective of that pipeline:</p>

<figure class="screenshot">
 <img src="/images/getting-started/gateways-to-VSM.png" />
  <figcaption>The labels of pipelines: gateways to VSM</figcaption>
</figure>

<p>Clicking on the label of the "Production" pipeline, takes you to its Value Stream Map, in which all of its upstream
pipelines and their source control materials are shown.</p>

<figure class="screenshot">
<img src="/images/getting-started/production-pipeline.png" />
  <figcaption>VSM from the view of the "Production" pipeline</figcaption>
</figure>

<p>Clicking on the label of the "Build" pipeline, either from the dashboard or the VSM view above, takes you to a similar
view with the perspective of the "Build" pipeline instance you clicked on. It is shown below. You can see that the
source material of "CapacityTesting" pipeline is not shown, because it is not directly downstream of the "Build"
pipeline.</p>

<figure class="screenshot">
<img src="/images/getting-started/build-pipeline.png" />
  <figcaption>VSM from the view of the "Build" pipeline</figcaption>
</figure>

<p>Now, that we know about the VSM, let's delve a little deeper into powerful concepts called fan-in and fan-out, which the
VSM visualizes.</p>

<h2 class="big-title" id="fan_out_fan_in">Fan-Out and Fan-In</h2>

<p>Let's start with the basic concepts and then use an example to understand this further.</p>

<section class="concept" id="concept_fan_out_fan_in">
  <h3>Concept 10: Fan-Out and Fan-In</h3>

  <h4>Fan-Out</h4>

  A pipeline "X" can be said to fan-out to downstream pipelines, when there are multiple downstream pipelines for which pipeline "X" is a dependency. It looks like this:

  <figure>
  <img src="/images/image07.png" />
  </figure>

  Similarly, a source material can be said to fan-out to downstream pipelines:

  <figure>
    <img src="/images/image08.png" />
  </figure>

  This brings in the advantages of parallelization and quicker feedback, which is a key goal of Continuous Delivery. As
  long as there are enough agents available, all three downstream dependencies will trigger together and can run
  together.

  <h4>Fan-In</h4>

  Opposite of fan-out. When multiple dependencies are used by a single pipeline, then the dependencies are said to fan-in to the pipeline. It looks like this:

  <figure>
     <img src="/images/image09.png" />
  </figure>

  In this example, there is a fan-in at the Production pipeline, from its two upstream pipelines and the git
  material. Similarly, there is a fan-in at the CapacityTesting pipeline. The important aspect of fan-in is not that
  there are multiple dependencies upstream, but the way that the pipeline is triggered, by ensuring that all of its
  dependencies are consistent in version, when the pipeline runs. This ensures correctness of the build, and quicker
  feedback through elimination of spurious builds.
</section>

<p>Let's bring back an earlier VSM view, from the Production pipeline perspective, with the links leading into the
Production pipeline emphasized a bit, by pinning it:</p>

<figure>
  <img src="/images/getting-started/part-3/image10.png">
  <figcaption>VSM with links pinned - showing fan-in</figcaption>
</figure>

<p>In this setup, the Build pipeline is said to fan-out to the UserAcceptance and CapacityTesting pipelines, and the git
material, UserAcceptance pipeline, and CapacityTesting pipeline are said to fan-in to the Production pipeline. From a
terminology perspective, that might make sense. But what does it really mean? Why is it important?</p>

<p>To understand that, let's consider what should happen when a commit (say C1) is made to the git material shown. Even
though the Production pipeline has a direct dependency on the git material, it should not be triggered
automatically. The correct order of triggering of pipelines is:</p>

<ol>
  <li>Build pipeline - with commit C1 (let's say the pipeline label of this is "Build_1").</li>
  <li>Once it succeeds, both UserAcceptance and CapacityTesting pipelines with "Build_1" as their dependency (say "UA_1" and "CT_1").</li>
  <li>Once they succeed, Production pipeline with git commit C1, pipeline dependency UA_1, and pipeline dependency CT_1.</li>
</ol>

<p>This ordering and consistency of versioning is what GoCD with fan-out and fan-in will ensure. There are two main reasons for this to be considered very important:</p>

<ol>
  <li>
    <p>
      <strong>Correctness</strong>: Without fan-in, if the CapacityTesting pipeline was slow and UserAcceptance pipeline
      was fast, then the Production pipeline could have been triggered with an old version of CapacityTesting pipeline
      and a new version of UserAcceptance pipeline. Imagine deploying to Production without really knowing that all
      upstream dependent pipelines have not finished successfully!
    </p>

    <p>
      A very important part of fan-out and fan-in is that a downstream pipeline will <em>always</em> figure out the
      correct upstream dependency versions, including repository materials, unless it is manually forced by a user not
      to.
    </p>

    <p>
      Similarly, any artifacts fetched from any upstream pipeline, however many levels up, is guaranteed to be consistent
      and correct. This means that the right revision of those artifacts will be fetched, irrespective of any other runs
      of that pipeline that may have run after.
    </p>
  </li>

  <li>
    <strong>Quicker feedback</strong>: By eliminating spurious builds which should never have been built (using wrong
    dependencies), fan-in provides quicker feedback. Similarly, fan-out allows multiple independent downstream pipelines
    to run simultaneously, providing quicker feedback.
  </li>
</ol>

<p>This has been a bit of a whirlwind tour of some of GoCD's concepts and ideas. To learn more about all the other features
and how to use them, head on over to the <a href="https://go.cd/documentation/user/current/">GoCD documentation</a> page.</p>

   

																				






				</div>
			</div>
		</div>
	</div>
    <div class="join-community">
	<div class="container">
		<h3>Join our community</h3>
		<ul>
			<li>
				<a href="#">
					<i class="fa fa-user-plus"></i>
					join us
				</a>
			</li>
			<li>
				<a href="#">
					<i class="fa fa-wechat"></i>
					Talk to us
				</a>
			</li>
			<li>
				<a href="#">
					<i class="fa fa-binoculars"></i>
					watch us
				</a>
			</li>
			<li>
				<a href="#">
					<i class="fa fa-twitter"></i>
					follow us
				</a>
			</li>
		</ul>
	</div>
</div>

<footer>
<div class="container">

            
<p class="help-us-improve">Make this place better, <a href="https://github.com/gocd/gocd.github.io/fork">fork</a> it or <a href="https://github.com/gocd/gocd.github.io/issues">suggest</a> something.</p>
<p>
Go is an open source project, sponsored by <a target="_blank" href="http://www.thoughtworks.com">ThoughtWorks Inc.</a> under the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" title="Apache 2.0 License">Apache License, Version 2.0</a>
</p>

        
</div>
<a href="#top">top</a>
</footer>
  </body>
</html>